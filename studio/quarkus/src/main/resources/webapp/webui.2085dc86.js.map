{"mappings":"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","sources":["<anon>","src/lg4j-executor.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire0031\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire0031\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $hNeh9 = parcelRequire(\"hNeh9\");\n\nvar $800sp = parcelRequire(\"800sp\");\n\nvar $8uVid = parcelRequire(\"8uVid\");\nconst $0ca21e1f1d158660$var$_DBG = (0, $8uVid.debug)({\n    on: true,\n    topic: 'LG4JExecutor'\n});\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').Instance} Instance\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */ /**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $0ca21e1f1d158660$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */ async function* $0ca21e1f1d158660$var$streamingResponse(response) {\n    // Attach Reader\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    while(reader){\n        // wait for next encoded chunk\n        const { done: done, value: value } = await reader.read();\n        // check if stream is done\n        if (done) break;\n        try {\n            buffer += decoder.decode(value);\n            const data = JSON.parse(buffer);\n            buffer = '';\n            yield data;\n        } catch (err) {\n            console.warn('JSON parse error:', err);\n        }\n    // Decodes data chunk and yields it\n    // yield (new TextDecoder().decode(value));\n    }\n}\nclass $0ca21e1f1d158660$export$2fe88ce002d9c04f extends (0, $800sp.LitElement) {\n    /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */ static styles = [\n        (0, $hNeh9.default),\n        (0, $800sp.css)`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `\n    ];\n    /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */ static properties = {\n        url: {\n            type: String,\n            reflect: true\n        },\n        test: {\n            type: Boolean,\n            reflect: true\n        },\n        _executing: {\n            state: true\n        }\n    };\n    /**\n   * @type {string | null }\n   */ url = null;\n    /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */ #selectedThread;\n    /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */ #updatedState = null;\n    /**\n   * Instance id\n   * \n   * @type {string|undefined} - instance id\n   */ #instanceId;\n    /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */ constructor(){\n        super();\n        this.test = false;\n        /** @type {ArgumentMetadata[]} */ this.formMetaData = [];\n        this._executing = false;\n    }\n    #startExecution() {\n        this._executing = true;\n        this.dispatchEvent(new CustomEvent('state-updated', {\n            detail: 'start',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n    /**\n   * \n   * @param {[ string, UpdatedState & { next: string } ]|Error|null} result \n   */ #stopExecution(result) {\n        this._executing = false;\n        // NO ACTION\n        if (!result) return;\n        // ON ERROR\n        if (result instanceof Error) {\n            this.dispatchEvent(new CustomEvent('state-updated', {\n                detail: 'error',\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n            return;\n        }\n        // ON SUCCESS\n        const [thread, { node: node }] = result;\n        // Asuume that flow is interrupted if last node is different by last node (__END__) \n        this.dispatchEvent(new CustomEvent('state-updated', {\n            detail: node !== '__END__' ? 'interrupted' : 'stop',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n    /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */ #onThreadUpdated(e) {\n        $0ca21e1f1d158660$var$_DBG('thread-updated', e.detail);\n        this.#selectedThread = e.detail;\n        this.#updatedState = null;\n        this.requestUpdate();\n    }\n    /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */ #onNodeUpdated(e) {\n        $0ca21e1f1d158660$var$_DBG('onNodeUpdated', e);\n        this.#updatedState = e.detail;\n        this.requestUpdate();\n    }\n    /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */ connectedCallback() {\n        super.connectedCallback();\n        // @ts-ignore\n        this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.addEventListener('node-updated', this.#onNodeUpdated);\n        // if (this.test) {\n        //   test.callInit(this)\n        //     .then(instance => {\n        //       this.formMetaData = instance.args \n        //       this.requestUpdate()\n        //     })\n        //   return\n        // }\n        this.#callInit();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        // @ts-ignore\n        this.removeEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.removeEventListener('node-updated', this.#onNodeUpdated);\n    }\n    /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */ render() {\n        return (0, $800sp.html)`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name: name, type: type })=>{\n            switch(type){\n                case 'STRING':\n                    return (0, $800sp.html)`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`;\n                case 'IMAGE':\n                    return (0, $800sp.html)`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`;\n            }\n        })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        <!--\n        ==============\n        ERROR DIALOG \n        ==============\n        -->\n        <dialog id=\"error_dialog\" class=\"modal\">\n          <div class=\"modal-box\">\n            <form method=\"dialog\">\n              <button class=\"btn btn-sm btn-circle btn-ghost absolute right-2 top-2\">✕</button>\n            </form>\n              <div class=\"flex items-center gap-2 mb-4 text-error\">\n              <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              class=\"h-6 w-6 shrink-0 stroke-current\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\">\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            <p id=\"error_message\" class=\"text-lg font-bold\">ERROR</p>\n          </div>\n          </div>\n        </dialog>        \n        `;\n    }\n    /**\n   * \n   * @param {string} detail \n   */ #requestShowError(detail) {\n        const elem = this.shadowRoot?.getElementById('error_dialog');\n        if (elem && 'showModal' in elem) {\n            const msgElem = elem.querySelector('#error_message');\n            if (msgElem) msgElem.textContent = detail;\n            //@ts-ignore\n            elem.showModal();\n        // if( timeout ) {\n        //   await delay(timeout)\n        //   //@ts-ignore\n        //   elem.close()\n        // }\n        }\n    }\n    async #callInit() {\n        const initResponse = await fetch(`${this.url}/init${window.location.search}`, {\n            method: 'GET',\n            credentials: 'include'\n        });\n        if (!initResponse.ok) {\n            this.#requestShowError(initResponse.statusText);\n            return null;\n        }\n        /** @type {Instance} */ const instance = await initResponse.json();\n        $0ca21e1f1d158660$var$_DBG('initData', instance);\n        this.dispatchEvent(new CustomEvent('init', {\n            detail: instance,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.#instanceId = instance.id;\n        this.formMetaData = instance.args;\n        // this.#nodes = initData.nodes\n        this.requestUpdate();\n    }\n    async #callResume() {\n        this.#startExecution();\n        let result = null;\n        try {\n            // if (this.test) {\n            //   await test.callSubmitAction(this, this.#selectedThread);\n            //   return\n            // }\n            result = await this.#callResumeAction();\n        } catch (err) {\n            if (err instanceof Error) {\n                this.#requestShowError(err.message);\n                result = err;\n            }\n        } finally{\n            this.#stopExecution(result);\n        }\n    }\n    async #callResumeAction() {\n        const execResponse = await fetch(`${this.url}/stream/${this.#instanceId}?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(this.#updatedState?.data)\n        });\n        if (!execResponse.ok) throw new Error(execResponse.statusText);\n        this.#updatedState = null;\n        /** @type [ string, UpdatedState & { next: string } ]|null */ let lastChunk = null;\n        for await (let detail of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            $0ca21e1f1d158660$var$_DBG(detail);\n            lastChunk = detail;\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n        return lastChunk;\n    }\n    async #callSubmit() {\n        this.#startExecution();\n        let result = null;\n        try {\n            // if (this.test) {\n            //   await test.callSubmitAction(this, this.#selectedThread);\n            // }\n            result = await this.#callSubmitAction();\n        } catch (err) {\n            if (err instanceof Error) {\n                this.#requestShowError(err.message);\n                result = err;\n            }\n        } finally{\n            this.#stopExecution(result);\n        }\n    }\n    async #callSubmitAction() {\n        // Get input as object\n        /** @type { Record<string,any> } */ const result = {};\n        /** @type { Record<string,any> } data */ const data = this.formMetaData.reduce((acc, md)=>{\n            const { name: name, type: type } = md;\n            const elem = this.shadowRoot?.getElementById(name);\n            switch(type){\n                case 'STRING':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n                case 'IMAGE':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n            }\n            return acc;\n        }, result);\n        const execResponse = await fetch(`${this.url}/stream/${this.#instanceId}?thread=${this.#selectedThread}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!execResponse.ok) throw new Error(execResponse.statusText);\n        /** @type [ string, UpdatedState & { next: string } ]|null */ let lastChunk = null;\n        for await (let detail of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            $0ca21e1f1d158660$var$_DBG('SUBMIT RESULT', detail);\n            // lastChunk = JSON.parse(chunk);\n            lastChunk = detail;\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n        return lastChunk;\n    }\n}\nwindow.customElements.define('lg4j-executor', $0ca21e1f1d158660$export$2fe88ce002d9c04f);\n\n\n//# sourceMappingURL=webui.2085dc86.js.map\n","\nimport TWStyles from './twlit.js';\n\nimport { html, css, LitElement, CSSResult } from 'lit';\n\n//import { imageToDiagram as test } from './lg4j-executor-test.js';\n\nimport { debug } from './debug.js';\n\nconst _DBG = debug( { on: true, topic: 'LG4JExecutor' } )\n\n\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').Instance} Instance\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */\nasync function* streamingResponse(response) {\n  // Attach Reader\n  const reader = response.body?.getReader();\n\n  const decoder = new TextDecoder();\n\n  let buffer = '';\n  while (true && reader) {\n    // wait for next encoded chunk\n    const { done, value } = await reader.read();\n    // check if stream is done\n    if (done) break;\n\n    try {\n      buffer += decoder.decode(value);\n      const data = JSON.parse(buffer);\n      buffer = '';\n      yield data;\n    } catch (err) {\n      console.warn('JSON parse error:', err );\n    }\n    // Decodes data chunk and yields it\n    // yield (new TextDecoder().decode(value));\n  }\n}\n\n/**\n * LG4JInputElement is a custom web component that extends LitElement.\n * It provides a styled input container with a placeholder.\n * \n * @class\n * @extends {LitElement}\n */\nexport class LG4JExecutorElement extends LitElement {\n\n  /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */\n  static styles = [TWStyles, css`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `];\n\n\n  /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */\n  static properties = {\n    url: { type: String, reflect: true },\n    test: { type: Boolean, reflect: true },\n    _executing: { state: true }\n\n  }\n\n  /**\n   * @type {string | null }\n   */\n  url = null\n\n  /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */\n  #selectedThread\n\n  /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */\n  #updatedState = null\n  \n  /**\n   * Instance id\n   * \n   * @type {string|undefined} - instance id\n   */\n  #instanceId;\n\n  /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */\n  constructor() {\n    super();\n    this.test = false\n    /** @type {ArgumentMetadata[]} */\n    this.formMetaData = []\n    this._executing = false\n\n  }\n\n  #startExecution() {\n\n    this._executing = true\n    this.dispatchEvent(new CustomEvent('state-updated', {\n      detail: 'start',\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n  }\n\n  /**\n   * \n   * @param {[ string, UpdatedState & { next: string } ]|Error|null} result \n   */\n  #stopExecution( result ) {\n    this._executing = false\n    \n    // NO ACTION\n    if( !result ) {\n      return\n    }\n\n    // ON ERROR\n    if( result instanceof Error ) {\n      this.dispatchEvent(new CustomEvent('state-updated', {\n        detail: 'error',\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n      return \n    }\n    // ON SUCCESS\n    const [ thread, { node } ] = result\n    // Asuume that flow is interrupted if last node is different by last node (__END__) \n    this.dispatchEvent(new CustomEvent('state-updated', {\n        detail: ( node!=='__END__' ) ? 'interrupted' : 'stop',\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n  }\n  \n\n  /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */\n  #onThreadUpdated(e) {\n    _DBG('thread-updated', e.detail)\n    this.#selectedThread = e.detail\n    this.#updatedState = null\n    this.requestUpdate()\n  }\n\n  /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */\n  #onNodeUpdated(e) {\n    _DBG('onNodeUpdated', e)\n    this.#updatedState = e.detail\n    this.requestUpdate()\n  }\n\n  /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    // @ts-ignore\n    this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n    // @ts-ignore\n    this.addEventListener('node-updated', this.#onNodeUpdated)\n\n    // if (this.test) {\n    //   test.callInit(this)\n    //     .then(instance => {\n    //       this.formMetaData = instance.args \n    //       this.requestUpdate()\n    //     })\n    //   return\n    // }\n\n    this.#callInit()\n\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    // @ts-ignore\n    this.removeEventListener(\"thread-updated\", this.#onThreadUpdated)\n    // @ts-ignore\n    this.removeEventListener('node-updated', this.#onNodeUpdated)\n  }\n\n  /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */\n  render() {\n\n    return html`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name, type }) => {\n            switch (type) {\n              case 'STRING':\n                return html`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`\n              case 'IMAGE':\n                return html`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`\n            }\n          })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        <!--\n        ==============\n        ERROR DIALOG \n        ==============\n        -->\n        <dialog id=\"error_dialog\" class=\"modal\">\n          <div class=\"modal-box\">\n            <form method=\"dialog\">\n              <button class=\"btn btn-sm btn-circle btn-ghost absolute right-2 top-2\">✕</button>\n            </form>\n              <div class=\"flex items-center gap-2 mb-4 text-error\">\n              <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              class=\"h-6 w-6 shrink-0 stroke-current\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\">\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            <p id=\"error_message\" class=\"text-lg font-bold\">ERROR</p>\n          </div>\n          </div>\n        </dialog>        \n        `;\n  }\n\n  /**\n   * \n   * @param {string} detail \n   */\n  #requestShowError( detail ) {\n\n    const elem = this.shadowRoot?.getElementById('error_dialog')\n    if (elem && 'showModal' in elem ) {\n      const msgElem = elem.querySelector('#error_message')\n      if( msgElem ) {\n        msgElem.textContent = detail\n      }\n      //@ts-ignore\n      elem.showModal()\n      \n      // if( timeout ) {\n      //   await delay(timeout)\n      //   //@ts-ignore\n      //   elem.close()\n      // }\n   }\n  \n  }\n\n  async #callInit() {\n  \n    const initResponse = await fetch(`${this.url}/init${window.location.search}`, {\n      method: 'GET',\n      credentials: 'include'\n    })\n\n    if( !initResponse.ok ) {\n      this.#requestShowError(initResponse.statusText) \n      return null\n    }\n  \n    /** @type {Instance} */\n    const instance = await initResponse.json()\n\n    _DBG('initData', instance);\n\n    this.dispatchEvent(new CustomEvent('init', {\n      detail: instance,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n\n    this.#instanceId = instance.id\n    this.formMetaData = instance.args\n    // this.#nodes = initData.nodes\n    this.requestUpdate()\n  }\n\n  async #callResume() {\n\n    this.#startExecution()\n    let result = null\n\n    try {\n\n      // if (this.test) {\n      //   await test.callSubmitAction(this, this.#selectedThread);\n      //   return\n      // }\n\n      result =  await this.#callResumeAction()\n\n    }\n    catch (err) {\n      if(err instanceof Error) {\n        this.#requestShowError(err.message)\n        result = err\n      }\n    }\n    finally {\n      this.#stopExecution(result)\n    }\n\n  }\n\n  async #callResumeAction() {\n\n    const execResponse = await fetch(`${this.url}/stream/${this.#instanceId}?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n      method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify( this.#updatedState?.data )\n    });\n\n    if( !execResponse.ok ) {\n      throw new Error( execResponse.statusText )\n    }\n\n    this.#updatedState = null\n\n    /** @type [ string, UpdatedState & { next: string } ]|null */\n    let lastChunk = null\n\n    for await (let detail of streamingResponse(execResponse)) {\n      _DBG( detail)\n      \n      lastChunk = detail\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n    }\n\n    return lastChunk\n\n  }\n\n  async #callSubmit() {\n\n    this.#startExecution()\n    let result = null\n\n    try {\n\n      // if (this.test) {\n      //   await test.callSubmitAction(this, this.#selectedThread);\n      // }\n\n      result = await this.#callSubmitAction()\n    }\n    catch (err) {\n      if(err instanceof Error) {\n        this.#requestShowError(err.message)\n        result = err\n      }\n    }\n    finally {\n        this.#stopExecution(result)\n\n    }\n  }\n\n  async #callSubmitAction() {\n\n    // Get input as object\n    /** @type { Record<string,any> } */\n    const result = {}\n    /** @type { Record<string,any> } data */\n    const data = this.formMetaData.reduce((acc, md) => {\n\n      const { name, type } = md\n      const elem = this.shadowRoot?.getElementById(name)\n\n      switch (type) {\n        case 'STRING':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n        case 'IMAGE':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n      }\n\n      return acc\n    }, result);\n\n    \n    const execResponse = await fetch(`${this.url}/stream/${this.#instanceId}?thread=${this.#selectedThread}`, {\n        method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n  \n    if( !execResponse.ok ) {\n      throw new Error( execResponse.statusText )\n    }\n\n    /** @type [ string, UpdatedState & { next: string } ]|null */\n    let lastChunk = null\n    \n    for await (let detail of streamingResponse(execResponse)) {\n      _DBG( 'SUBMIT RESULT', detail)\n\n      // lastChunk = JSON.parse(chunk);\n      lastChunk = detail\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n\n    }\n    \n    return lastChunk\n\n  }\n\n}\nwindow.customElements.define('lg4j-executor', LG4JExecutorElement);\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$hNeh9","$800sp","$0ca21e1f1d158660$var$_DBG","$8uVid","debug","on","topic","$0ca21e1f1d158660$var$streamingResponse","response","reader","body","getReader","decoder","TextDecoder","buffer","done","value","read","decode","data","JSON","parse","console","warn","$0ca21e1f1d158660$export$2fe88ce002d9c04f","LitElement","styles","default","css","properties","url","type","String","reflect","test","Boolean","_executing","state","formMetaData","dispatchEvent","CustomEvent","detail","bubbles","composed","cancelable","result","thread","node","e","requestUpdate","connectedCallback","addEventListener","disconnectedCallback","removeEventListener","render","html","map","name","elem","shadowRoot","getElementById","msgElem","querySelector","textContent","showModal","initResponse","fetch","window","location","search","method","credentials","ok","statusText","instance","json","args","message","execResponse","checkpoint","headers","stringify","lastChunk","reduce","acc","md","customElements","define"],"version":3,"file":"webui.2085dc86.js.map"}